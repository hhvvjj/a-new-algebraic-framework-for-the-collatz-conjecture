<!--
/**
 * ============================================================================
 * TOTAL STOPPING TIME PREDICTOR
 * ============================================================================
 * 
 * A web-based interactive tool for calculating and visualizing Collatz 
 * Conjecture stopping times using advanced optimization techniques.
 * 
 * MATHEMATICAL FOUNDATION:
 * Based on "On the Convergence of Collatz Sequences: A New Algebraic Framework"
 * by Javier Hernandez (2026).
 * https://doi.org/10.5281/zenodo.15546925
 * 
 * CONCEPT:
 * The total stopping time σ(n) is the number of iterations required to reach 
 * 1 starting from n. Traditional computation requires applying the Collatz 
 * function iteratively until reaching 1.
 * 
 * ALGORITHMIC APPROACHES:
 * This tool implements four distinct algorithms:
 * 
 *   • Multiplicity Algorithm: Instant calculation using pre-computed patterns
 *   • Wormhole Algorithm: Hybrid approach leveraging known subsequences
 *   • Standard Algorithm: Traditional iterative computation
 *       - Powers of 2 Algorithm: Instant calculation for Standard where n = 2^k 
 * 
 * EFFICIENCY:
 * These optimizations dramatically reduce computational overhead, achieving 
 * up to 100% efficiency for powers of 2, multiplicity and certain wormholes 
 * where n=e(m_r).
 * 
 * PREDICTION METHODS:
 * 
 * 1. MULTIPLICITIES ALGORITHM (Section 9.2, Theorem 9.3):
 *    - For n = n₀ × 2^k where n₀ is an entry point
 *    - Formula: σ(n) = σ(n₀) + k
 *    - Efficiency: 100% (instant calculation, no iteration)
 *    - Example: σ(48) = σ(6) + 3 = 8 + 3 = 11
 * 
 * 2. WORMHOLE ALGORITHM (Section 9.3, Theorem 9.7):
 *    - Computes until reaching known entry point e(m_r)
 *    - Formula: σ(n) = k + τ(m_r)
 *    - Efficiency: (saved_steps / total_steps) × 100%
 *    - Example: σ(27) = 16 + 95 = 111 (85.6% efficient)
 * 
 * 3.1 STANDARD ALGORITHM:
 *    - Full iterative computation (fallback method)
 *    - Used when no optimization applies
 *    - Efficiency: 0% (no steps saved)
 *    - Belongs to S(m_r = 0)
 *
 * 3.2 STANDARD ALGORITHM WHERE n IS POWERS OF 2:
 *    - For n = 2^k (pure powers of 2)
 *    - Formula: σ(n) = k
 *    - Efficiency: 100% (instant calculation, no iteration)
 *    - Example: σ(16) = log₂(16) = 4
 *    - Belongs to S(m_r = 0)
 * 
 * INTERACTIVE FEATURES:
 * 1. Input validation with clear error messages
 * 2. Real-time computation with loading indicator
 * 3. Comprehensive results display:
 *    - Algorithm used and efficiency metrics
 *    - Sequence comparison (standard vs optimized)
 *    - Strategy explanation with detailed calculations
 * 4. Color-coded visualization:
 *    - Blue: Powers of 2 (trivial case)
 *    - Yellow: Computed steps
 *    - Green: Saved steps (wormhole optimization)
 * 5. Mathematical notation and formula display
 * 
 * DICTIONARIES:
 * - MULTIPLICITIES_DICTIONARY: 28 base entry points with pre-computed lengths
 * - WORMHOLES_DICTIONARY: 13 primary wormhole sequences with complete trajectories
 * 
 * COMPUTATIONAL LIMITS:
 * - Maximum input: 2^50 (~ 1.1 quadrillion)
 * - Maximum iterations: 10,000 steps (safety limit)
 * - Tested and verified for all n < 2^40
 * 
 * THEORETICAL SIGNIFICANCE:
 * Demonstrates practical application of the algebraic framework's invariance 
 * properties (Theorems 6.6, 6.8) for efficient stopping time prediction without 
 * complete sequence iteration. Powers of 2 represent the simplest case of 
 * convergence to S(0).
 * 
 * AUTHOR: Javier Hernandez
 * EMAIL: 271314@pm.me
 * LICENSE: https://github.com/hhvvjj/a-new-algebraic-framework-for-the-collatz-conjecture/blob/main/LICENSE
 * REPOSITORY: https://github.com/hhvvjj/a-new-algebraic-framework-for-the-collatz-conjecture/tree/main/step05-total-stopping-time-predictor
 * 
 * ============================================================================
 */
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Total Stopping Time Predictor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #2a2a2a;
            min-height: 100vh;
            padding: 0;
            padding-bottom: 1px;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .header {
            background: #000000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            padding: 20px 40px;
            border-radius: 12px;
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            backdrop-filter: blur(15px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        h1 {
            text-align: left;
            color: #ffffff;
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 15px rgba(102, 126, 234, 0.4);
        }

        .input-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        input[type="number"] {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #667eea;
            border-radius: 8px;
            width: 200px;
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            transition: all 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #7c8ef5;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        }

        button {
            padding: 12px 30px;
            font-size: 16px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
            min-width: 120px;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #4a4a4a;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .content {
            margin-top: 120px;
            margin-bottom: 120px;
            padding: 0 40px;
            display: none;
            flex-direction: column;
            gap: 30px;
        }

        .content.active {
            display: flex;
        }

        .info-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .section-title {
            font-size: 1.3em;
            color: #ffffff;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-card {
            background: rgba(102, 126, 234, 0.2);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .info-label {
            font-size: 0.9em;
            color: #d0d0d0;
            margin-bottom: 8px;
        }

        .info-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffffff;
        }

        .sequence-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .sequence-display {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid rgba(255,255,255,0.1);
            margin-top: 15px;
        }

        .sequence-row {
            margin-bottom: 20px;
        }

        .sequence-label {
            color: #999;
            font-size: 0.9em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .sequence-values {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
        }

        .sequence-num {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }

        .arrow {
            color: #999;
            margin: 0 3px;
        }

        .power-of-2-value {
            color: #3498db;
            font-weight: bold;
        }

        .computed-value {
            color: #fdcb6e;
            font-weight: bold;
        }

        .saved-value {
            color: #2ecc71;
            font-weight: bold;
        }

        .strategy-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .strategy-content {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-top: 15px;
        }

        .strategy-item {
            margin-bottom: 10px;
            padding-left: 20px;
            position: relative;
        }

        .validation-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .validation-badge {
            display: inline-block;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            margin-top: 15px;
        }

        .validation-badge.passed {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
            color: #2ecc71;
        }

        .validation-badge.failed {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            color: #e74c3c;
        }

        #error {
            margin-top: 120px;
            padding: 0 40px;
        }

        .error-message {
            background: #7f1d1d;
            border: 1px solid #fcc;
            color: #fee;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .author-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            font-size: 0.9em;
            color: #999;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .author-info a {
            color: #667eea;
            text-decoration: none;
        }

        .author-info a:hover {
            text-decoration: underline;
            color: #7c8ef5;
        }

        .loading {
            text-align: center;
            padding: 60px;
            font-size: 1.3em;
            color: #999;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 25px;
            flex-wrap: wrap;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
    </style>
</head>

<body>
    <div class="header">
        <div>
            <h1>Total Stopping Time Predictor</h1>
        </div>
        
        <div class="input-section">
            <input type="number" id="numberInput" min="1" placeholder="Enter n > 0">
            <button onclick="processNumber()">Process</button>
        </div>
    </div>

    <div id="error" style="display: none;"></div>

    <div id="content" class="content">
        <div class="info-section">
            <div class="section-title">Analysis Results for n = <span id="inputValue">-</span></div>
            <div class="info-grid" id="infoGrid"></div>
        </div>

        <div class="sequence-section">
            <div class="section-title">Sequence Comparison</div>
            <div class="sequence-display" id="sequenceDisplay"></div>
        </div>

        <div class="strategy-section" id="strategySection">
            <div class="section-title">Optimization Strategy</div>
            <div class="strategy-content" id="strategyContent"></div>
        </div>

        <div class="validation-section" id="validationSection" style="display: none;">
            <div class="section-title">Wormhole Validation</div>
            <div id="validationContent"></div>
        </div>

    </div>

    <div class="author-info">
        <p><strong>Author:</strong> Javier Hernandez | <strong>Email:</strong> 271314@pm.me</p>
        <a href="https://github.com/hhvvjj/a-new-algebraic-collatz-framework/tree/main/step05-total-stopping-time-predictor" target="_blank">Go To GitHub Repository</a> |
        <a href="https://github.com/hhvvjj/a-new-algebraic-collatz-framework/blob/main/LICENSE" target="_blank">License</a> | 
        <a href="https://doi.org/10.5281/zenodo.15546925" target="_blank">Research Reference</a>
    </div>

    <script>
        /**
         * Maximum number of computation steps allowed before terminating.
         * Prevents infinite loops in potentially divergent sequences.
         */
        const MAX_COMPUTATION_STEPS = 10000;

        /**
         * Maximum input value accepted (2^50).
         * Prevents overflow and ensures reasonable computation times.
         */
        const MAX_INPUT_VALUE = Math.pow(2, 50);

        /**
         * Multiplicities dictionary for instant stopping time calculation.
         * 
         * Maps base indices to their properties for the multiplicities algorithm.
         * If n = index × 2^k, then stopping_time = k + tau_mr.
         * 
         * @type {Object<number, {mr: number, tau_mr: number}>}
         * @property {number} mr - The mr class value for this index
         * @property {number} tau_mr - Pre-computed stopping time for the base index
         */
        const MULTIPLICITIES_DICTIONARY = {
            3: { mr: 1, tau_mr: 7 },
            6: { mr: 2, tau_mr: 8 },
            7: { mr: 3, tau_mr: 16 },
            15: { mr: 7, tau_mr: 17 },
            18: { mr: 8, tau_mr: 20 },
            33: { mr: 16, tau_mr: 26 },
            39: { mr: 19, tau_mr: 34 },
            51: { mr: 25, tau_mr: 24 },
            108: { mr: 53, tau_mr: 113 },
            159: { mr: 79, tau_mr: 54 },
            183: { mr: 91, tau_mr: 93 },
            243: { mr: 121, tau_mr: 96 },
            252: { mr: 125, tau_mr: 109 },
            333: { mr: 166, tau_mr: 112 },
            378: { mr: 188, tau_mr: 107 },
            411: { mr: 205, tau_mr: 133 },
            501: { mr: 250, tau_mr: 110 },
            975: { mr: 487, tau_mr: 142 },
            1185: { mr: 592, tau_mr: 150 },
            1299: { mr: 649, tau_mr: 145 },
            1335: { mr: 667, tau_mr: 145 },
            1368: { mr: 683, tau_mr: 127 },
            1731: { mr: 865, tau_mr: 148 },
            1779: { mr: 889, tau_mr: 148 },
            2307: { mr: 1153, tau_mr: 151 },
            2430: { mr: 1214, tau_mr: 164 },
            4857: { mr: 2428, tau_mr: 165 },
            7287: { mr: 3643, tau_mr: 163 }
        };

        /**
         * Wormholes dictionary for hybrid stopping time calculation.
         * 
         * Contains pre-computed complete sequences from entry points to 1.
         * When a sequence reaches an entry point, remaining trajectory is known.
         * 
         * @type {Object<number, {wormhole: number[], mr: number, pseudocycle: number[]}>}
         * @property {number[]} wormhole - Complete sequence from entry point to 1
         * @property {number} mr - The mr class value for this entry point
         * @property {number[]} pseudocycle - The pseudocycle pair [first, second]
         * 
         * @type {Object<number, {mr: number, wormhole: number[]}>}
         * @property {number} mr - The mr class value for this entry point
         * @property {number[]} wormhole - Complete sequence from entry point to 1
         */
        const WORMHOLES_DICTIONARY = {
            14: { mr: 6, wormhole: [14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1] },
            19: { mr: 9, wormhole: [19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1] },
            25: { mr: 12, wormhole: [25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1] },
            91: { mr: 45, wormhole: [91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            121: { mr: 60, wormhole: [121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            284: { mr: 141, wormhole: [284,142,71,214,107,322,161,484,242,121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            487: { mr: 243, wormhole: [487,1462,731,2194,1097,3292,1646,823,2470,1235,3706,1853,5560,2780,1390,695,2086,1043,3130,1565,4696,2348,1174,587,1762,881,2644,1322,661,1984,992,496,248,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            649: { mr: 324, wormhole: [649,1948,974,487,1462,731,2194,1097,3292,1646,823,2470,1235,3706,1853,5560,2780,1390,695,2086,1043,3130,1565,4696,2348,1174,587,1762,881,2644,1322,661,1984,992,496,248,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            667: { mr: 333, wormhole: [667,2002,1001,3004,1502,751,2254,1127,3382,1691,5074,2537,7612,3806,1903,5710,2855,8566,4283,12850,6425,19276,9638,4819,14458,7229,21688,10844,5422,2711,8134,4067,12202,6101,18304,9152,4576,2288,1144,572,286,143,430,215,646,323,970,485,1456,728,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            865: { mr: 432, wormhole: [865,2596,1298,649,1948,974,487,1462,731,2194,1097,3292,1646,823,2470,1235,3706,1853,5560,2780,1390,695,2086,1043,3130,1565,4696,2348,1174,587,1762,881,2644,1322,661,1984,992,496,248,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            889: { mr: 444, wormhole: [889,2668,1334,667,2002,1001,3004,1502,751,2254,1127,3382,1691,5074,2537,7612,3806,1903,5710,2855,8566,4283,12850,6425,19276,9638,4819,14458,7229,21688,10844,5422,2711,8134,4067,12202,6101,18304,9152,4576,2288,1144,572,286,143,430,215,646,323,970,485,1456,728,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            1153: { mr: 576, wormhole: [1153,3460,1730,865,2596,1298,649,1948,974,487,1462,731,2194,1097,3292,1646,823,2470,1235,3706,1853,5560,2780,1390,695,2086,1043,3130,1565,4696,2348,1174,587,1762,881,2644,1322,661,1984,992,496,248,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] },
            3643: { mr: 1821, wormhole: [3643,10930,5465,16396,8198,4099,12298,6149,18448,9224,4612,2306,1153,3460,1730,865,2596,1298,649,1948,974,487,1462,731,2194,1097,3292,1646,823,2470,1235,3706,1853,5560,2780,1390,695,2086,1043,3130,1565,4696,2348,1174,587,1762,881,2644,1322,661,1984,992,496,248,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,175,526,263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1] }
        };

        /**
         * Validates that the user input is a valid number within acceptable limits.
         * 
         * This function performs comprehensive validation of user input to ensure it meets
         * all requirements for Collatz sequence processing. It checks for emptiness, numeric
         * validity, positivity, and compliance with the maximum value constraint.
         * 
         * @param {string|number} n - The user input value to validate
         * @returns {number} The validated positive integer
         * @throws {Error} If input is empty, not a valid number, not positive, or exceeds MAX_INPUT_VALUE
         * 
         * @example
         * validateInput(27)      // Returns: 27
         * validateInput("100")   // Returns: 100
         * validateInput("")      // Throws: "Input cannot be empty"
         * validateInput(-5)      // Throws: "n must be positive"
         * validateInput(2**51)   // Throws: "n too large (limit: 1125899906842624)"
         */
        function validateInput(n) {
            // Check if input is empty or null
            if (!n || n === '') {
                throw new Error("Input cannot be empty");
            }
            
            // Convert to integer
            const num = parseInt(n);
            
            // Verify it is a valid number
            if (isNaN(num)) {
                throw new Error("Input must be a valid number");
            }
            
            // Verify it is positive
            if (num <= 0) {
                throw new Error("n must be positive");
            }
            
            // Verify it does not exceed the maximum limit
            if (num > MAX_INPUT_VALUE) {
                throw new Error(`n too large (limit: ${MAX_INPUT_VALUE})`);
            }
            
            return num;
        }

        /**
         * Calculates the next value in the Collatz sequence according to the standard rules.
         * 
         * Applies the fundamental Collatz function:
         * - If n is even: returns n/2
         * - If n is odd: returns 3n+1
         * 
         * This is the core operation that defines the Collatz conjecture dynamics.
         * 
         * @param {number} n - The current number in the sequence (must be positive integer)
         * @returns {number} The next number in the Collatz sequence
         * 
         * @example
         * nextCollatzValue(6)  // Returns: 3  (6 is even → 6/2)
         * nextCollatzValue(5)  // Returns: 16 (5 is odd → 3*5+1)
         * nextCollatzValue(1)  // Returns: 4  (1 is odd → 3*1+1)
         */
        function nextCollatzValue(n) {
            if (n % 2 === 0) {
                return n / 2;
            } else {
                return 3 * n + 1;
            }
        }

        /**
        * Checks if a number is a power of 2 using bitwise operation.
        * 
        * Uses the bitwise trick: a number n is a power of 2 if and only if
        * n > 0 and (n & (n-1)) === 0. This works because powers of 2 have
        * exactly one bit set in their binary representation.
        * 
        * Binary examples:
        * 8 (binary: 1000) & 7 (binary: 0111) = 0 → true
        * 16 (binary: 10000) & 15 (binary: 01111) = 0 → true
        * 6 (binary: 0110) & 5 (binary: 0101) = 0100 ≠ 0 → false
        * 
        * ROBUSTNESS:
        * The function handles both string and number inputs by converting to integer.
        * This prevents type-related bugs when n comes from DOM elements or user input.
        * 
        * @param {number|string} n - The number to check (accepts both types)
        * @returns {boolean} True if n is a power of 2, false otherwise
        * 
        * @example
        * isPowerOf2(8)      // Returns: true  (2³)
        * isPowerOf2("8")    // Returns: true  (handles string)
        * isPowerOf2(16)     // Returns: true  (2⁴)
        * isPowerOf2("512")  // Returns: true  (2⁹)
        * isPowerOf2(6)      // Returns: false
        * isPowerOf2("6")    // Returns: false
        * isPowerOf2(1)      // Returns: true  (2⁰)
        * isPowerOf2(0)      // Returns: false
        * isPowerOf2("abc")  // Returns: false (NaN handling)
        */
        function isPowerOf2(n) {
            // Convert to integer if string, handle edge cases
            const num = typeof n === 'string' ? parseInt(n, 10) : n;
            
            // Validate: must be a valid positive number
            if (isNaN(num) || num <= 0) {
                return false;
            }
            
            // Bitwise check: n is power of 2 iff (n & (n-1)) === 0
            return (num & (num - 1)) === 0;
        }

        /**
         * Calculates the stopping time using the MULTIPLICITIES algorithm (instant calculation).
         * 
         * This is the SECOND MOST EFFICIENT method when applicable, achieving 100% efficiency by
         * avoiding ALL computation through pre-calculated values.
         * 
         * CONCEPT:
         * If n = index × 2^k, where index is in MULTIPLICITIES_DICTIONARY, then:
         * total_stopping_time = k + tau_mr
         * 
         * This exploits the mathematical property that multiplying an entry point by
         * powers of 2 adds exactly one step per power (since each division by 2 is
         * one Collatz iteration).
         * 
         * ALGORITHM:
         * 1. Check if n is divisible by any dictionary index
         * 2. Verify that n/index is a power of 2 (ratio = 2^k)
         * 3. Calculate: total_stopping_time = log₂(ratio) + tau_mr
         * 
         * IMPORTANT: Iterates entries in descending order (largest index first) to ensure
         * correct classification when an index is a multiple of another (e.g., e(mr)=6 vs e(mr)=3)
         * .
         * @param {number} n - The number to analyze (must be positive integer)
         * @returns {Object|null} Result object if multiplicity found, null otherwise
         * 
         * @returns {Object} result - The multiplicity calculation result
         * @returns {number} result.total_stopping_time - The calculated stopping time
         * @returns {string} result.algorithm - Always "multiplicity"
         * @returns {string} result.prediction_type - Always "multiplicity_found"
         * @returns {number} result.index_used - Which dictionary index was used
         * @returns {number} result.ratio - n/index (always a power of 2)
         * @returns {number} result.tau_mr - Pre-calculated length for the index
         * @returns {number} result.analytical_steps - log₂(ratio)
         * @returns {number} result.mr_value - The mr class value
         * @returns {number} result.n - The input value (for reference)
         * 
         * @example
         * // n = 48, index = 6, ratio = 8 = 2³
         * calculateMultiplicityStoppingTime(48)
         * // Returns: {
         * //   total_stopping_time: 11,  // tau_mr(6) + 3 = 8 + 3
         * //   algorithm: "multiplicity",
         * //   prediction_type: "multiplicity_found",
         * //   index_used: 6,
         * //   ratio: 8,
         * //   tau_mr: 8,
         * //   analytical_steps: 3,
         * //   mr_value: 2,
         * //   n: 48
         * // }
         * 
         * calculateMultiplicityStoppingTime(27)  // Returns: null (not a multiplicity)
         */
        function calculateMultiplicityStoppingTime(n) {

            // FAST-PATH: Pure powers of 2 (n = 2^k, where e(m_r)=1)
            // σ(2^k) = k, η=1 (no iteration required)
            if (isPowerOf2(n)) {
                const k = Math.log2(n);
                return {
                    total_stopping_time: k,
                    algorithm: "multiplicity",
                    prediction_type: "multiplicity_found",
                    index_used: 1,
                    ratio: n,
                    tau_mr: 0,
                    analytical_steps: k,
                    mr_value: 0,
                    n: n
                };
            }

            // Iterate through all indices in the multiplicities dictionary
            for (const [index, data] of Object.entries(MULTIPLICITIES_DICTIONARY).sort((a, b) => b[0] - a[0])) {
                const idx = parseInt(index);

                // Check if n is divisible by this index
                if (n % idx === 0) {

                    // Calculate additional steps as log2(ratio)
                    const ratio = n / idx;
                    if (isPowerOf2(ratio)) {
                        const analyticalSteps = Math.log2(ratio);

                        // Total stopping time = additional steps + tau_mr
                        const totalStoppingTime = analyticalSteps + data.tau_mr;
                        
                        // Return the result object
                        return {
                            total_stopping_time: totalStoppingTime,
                            algorithm: "multiplicity",
                            prediction_type: "multiplicity_found",
                            index_used: idx,
                            ratio: ratio,
                            tau_mr: data.tau_mr,
                            analytical_steps: analyticalSteps,
                            n: n,
                            mr_value: data.mr
                        };
                    }
                }
            }

            // No multiplicity pattern found
            return null;
        }

        /**
         * Generates the complete standard Collatz sequence from n to 1 (brute-force method).
         * 
         * This is the traditional iterative method without any optimizations. It applies
         * the Collatz function repeatedly until reaching 1, storing each intermediate value.
         * 
         * PROCESS:
         * 1. Start with n
         * 2. Apply Collatz rules: if even → n/2, if odd → 3n+1
         * 3. Continue until reaching 1
         * 4. Return the complete sequence including 1
         * 
         * SAFETY:
         * Includes a safeguard against infinite loops by limiting iterations to
         * MAX_COMPUTATION_STEPS (10,000). This prevents the function from hanging
         * on potentially divergent sequences.
         * 
         * @param {number} n - The starting number (must be positive integer)
         * @returns {Array<number>} Array containing the complete sequence from n to 1
         * @throws {Error} If sequence exceeds MAX_COMPUTATION_STEPS iterations
         * 
         * @example
         * generateStandardSequence(6)
         * // Returns: [6, 3, 10, 5, 16, 8, 4, 2, 1]
         * // Steps = sequence.length - 1 = 8
         * 
         * generateStandardSequence(27)
         * // Returns: [27, 82, 41, ..., 4, 2, 1]
         * // Steps = 111
         * 
         * generateStandardSequence(1)
         * // Returns: [1]
         * // Steps = 0
         */
        function generateStandardSequence(n) {
            const sequence = [];      // Array to store the sequence
            let current = n;          // Start with the input number
            let steps = 0;            // Counter for safety limit
            
            // Continue until we reach 1
            while (current !== 1 && steps < MAX_COMPUTATION_STEPS) {
                sequence.push(current);              // Add current number to sequence
                current = nextCollatzValue(current); // Calculate next value
                steps++;                             // Increment step counter
            }
            
            // Safety check: throw error if computation is too long
            if (steps >= MAX_COMPUTATION_STEPS) {
                throw new Error(`Sequence too long for n=${n}`);
            }
            
            // Add the final 1 to the sequence
            sequence.push(1);
            return sequence;
        }

        /**
         * Calculates the optimized stopping time using the best available algorithm.
         * 
         * This is the MAIN OPTIMIZATION FUNCTION that orchestrates the entire prediction
         * strategy. It tries algorithms in order of efficiency, using the first applicable one.
         * 
         * STRATEGY (in priority order):
         * 1. Try MULTIPLICITIES algorithm first (instant, 100% efficient; includes powers of 2 as special case)
         * 2. If not applicable, use WORMHOLE algorithm (hybrid approach)
         * 3. Worst case: full computation required
         * 
         * RETURN VALUE TYPES:
         * 
         * POWER OF 2 RESULT (highest priority, most trivial):
         * - total_stopping_time: log₂(n)
         * - algorithm: "power_of_2"
         * - prediction_type: "power_of_2"
         * - Additional fields: exponent, mr_value (always 0)
         * 
         * MULTIPLICITY RESULT (second priority):
         * - total_stopping_time: calculated instantly via formula
         * - algorithm: "multiplicity"
         * - prediction_type: "multiplicity_found"
         * - Additional fields: index_used, ratio, tau_mr, analytical_steps, mr_value
         * 
         * WORMHOLE RESULT (entry point found):
         * - total_stopping_time: computed_steps + tau_mr
         * - algorithm: "wormhole"
         * - prediction_type: "entry_point_found"
         * - Additional fields: entry_point_found, entry_point_position, computed_steps,
         *   tau_mr, wormhole_length, mr_value
         * 
         * STANDARD RESULT (no optimization available):
         * - total_stopping_time: fully computed via iteration
         * - algorithm: "wormhole"
         * - prediction_type: "no_entry_point" or "trivial"
         * - Additional fields: computed_steps, saved_steps (0)
         * 
         * @param {number} n - The number to analyze (must be positive integer)
         * @returns {Object} Result object with stopping time and method details
         * @throws {Error} If computation exceeds MAX_COMPUTATION_STEPS iterations
         * 
         * @example
         * calculateOptimizedStoppingTime(16)
         * // Returns: { total_stopping_time: 4, algorithm: "power_of_2", exponent: 4, ... }
         * 
         * calculateOptimizedStoppingTime(48)
         * // Returns: { total_stopping_time: 11, algorithm: "multiplicity", ... }
         * 
         * calculateOptimizedStoppingTime(27)
         * // Returns: { total_stopping_time: 111, algorithm: "wormhole",
         * //           prediction_type: "entry_point_found", computed_steps: 16,
         * //           saved_steps: 95, entry_point_found: 121, ... }
         * 
         * calculateOptimizedStoppingTime(31)
         * // Returns: { total_stopping_time: 106, algorithm: "wormhole",
         * //           prediction_type: "no_entry_point", computed_steps: 106,
         * //           saved_steps: 0 }
         */
        function calculateOptimizedStoppingTime(n) {

            // PRIORITY 1: Try multiplicities algorithm (includes powers of 2 as special case)
            const multiplicityResult = calculateMultiplicityStoppingTime(n);
            if (multiplicityResult !== null) {
                return multiplicityResult;
            }
            
            // TRIVIAL CASE: n = 1 (already handled by power of 2, but kept for safety)
            if (n === 1) {
                return {
                    total_stopping_time: 0,
                    algorithm: "wormhole",
                    prediction_type: "trivial",
                    computed_steps: 0,
                    saved_steps: 0
                };
            }
            
            // PRIORITY 2: Use wormhole algorithm (hybrid approach)
            let current = n;
            let steps = 0;
            
            // Compute sequence until we find a wormhole or reach 1
            while (current !== 1) {
                // CHECK: Is this a wormhole entry point?
                if (WORMHOLES_DICTIONARY[current]) {
                    const wormholeSeq = WORMHOLES_DICTIONARY[current].wormhole;
                    const tau_mr = wormholeSeq.length - 1;
                    const totalSteps = steps + tau_mr;
                    
                    // Return wormhole result
                    return {
                        total_stopping_time: totalSteps,
                        algorithm: "wormhole",
                        prediction_type: "entry_point_found",
                        entry_point_found: current,
                        entry_point_position: steps,
                        computed_steps: steps,
                        tau_mr: tau_mr,
                        wormhole_length: wormholeSeq.length,
                        mr_value: WORMHOLES_DICTIONARY[current].mr
                    };
                }
                
                // No wormhole yet, continue computing
                current = nextCollatzValue(current);
                steps++;
                
                // Safety check: prevent infinite loops
                if (steps > MAX_COMPUTATION_STEPS) {
                    throw new Error(`Exceeded ${MAX_COMPUTATION_STEPS} steps`);
                }
            }
            
            // PRIORITY 3: Reached 1 without finding any optimization (WORST CASE)
            return {
                total_stopping_time: steps,
                algorithm: "wormhole",
                prediction_type: "no_entry_point",
                computed_steps: steps,
                saved_steps: 0
            };
        }

        /**
         * Main processing function triggered when user clicks "Process" button.
         * 
         * Orchestrates the entire workflow from user input to results display.
         * This function coordinates validation, computation, and UI updates while
         * handling errors gracefully.
         * 
         * WORKFLOW:
         * 1. Clear any previous errors from the display
         * 2. Validate user input (check for valid number, positive, within limits)
         * 3. Show loading indicator to provide user feedback
         * 4. Generate standard sequence (for comparison purposes)
         * 5. Calculate optimized result (tries powers of 2, then multiplicities, then wormholes)
         * 6. Display all results (info cards, sequences, strategy explanation)
         * 
         * ERROR HANDLING:
         * - Input validation errors: shown immediately before computation
         * - Computation errors: shown after attempting calculation
         * 
         * UI UPDATES:
         * - Shows/hides error div based on validation/computation results
         * - Shows/hides content div to display results
         * - Updates all result displays via specialized display functions
         * 
         * ASYNC PATTERN:
         * Uses setTimeout to allow UI to update before heavy computation begins,
         * preventing the interface from freezing during long calculations.
         * 
         * @returns {void} No return value; updates DOM directly
         * 
         * @example
         * // User enters 27 and clicks "Process"
         * processNumber()
         * // → Validates input
         * // → Shows loading
         * // → Computes sequences
         * // → Displays results with efficiency metrics
         * 
         * // User enters invalid input
         * processNumber()
         * // → Shows error message
         * // → Does not proceed to computation
         */
        function processNumber() {
            // Get DOM elements
            const errorDiv = document.getElementById('error');

            // Clear previous errors
            errorDiv.style.display = 'none';
            errorDiv.innerHTML = '';
            
            const input = document.getElementById('numberInput');
            
            try {
                // STEP 1: Validate input
                const n = validateInput(input.value);
                
                // STEP 2: Update UI with input value
                document.getElementById('inputValue').textContent = n;
                
                // STEP 3: Show loading indicator
                const content = document.getElementById('content');
                const infoGrid = document.getElementById('infoGrid');
                
                infoGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 20px;"><div class="loading">Processing</div></div>';
                content.classList.add('active');
                
                // STEP 4: Perform calculations after UI updates (setTimeout)
                // This prevents UI from freezing during heavy computation
                setTimeout(() => {
                    try {
                        // Generate standard sequence (for comparison)
                        const standardSequence = generateStandardSequence(n);
                        // Calculate optimized result
                        const optimizedResult = calculateOptimizedStoppingTime(n);
                        
                        // STEP 5: Display all results
                        displayResults(n, standardSequence, optimizedResult);
                    } catch (error) {
                        // Computation error occurred
                        errorDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                        errorDiv.style.display = 'block';
                        content.classList.remove('active');
                    }
                }, 100);
                
            } catch (error) {
                // Validation error occurred
                errorDiv.innerHTML = `<div class="error-message">${error.message}</div>`;
                errorDiv.style.display = 'block';
            }
        }

        /**
         * Master display function that coordinates all result visualizations.
         * 
         * This function acts as a coordinator, delegating to specialized display functions
         * in the correct order. It ensures a consistent presentation of results across
         * all three main visualization areas.
         * 
         * DISPLAY ORDER:
         * 1. Info cards - Key metrics and statistics (algorithm used, stopping times, efficiency)
         * 2. Sequences - Standard vs Optimized comparison with visual color coding
         * 3. Strategy - Explanation of optimization method used
         * 
         * DESIGN PATTERN:
         * This is a facade pattern that simplifies the complex process of displaying
         * multiple related result sections. It ensures all displays receive consistent
         * data and are updated in the proper sequence.
         * 
         * @param {number} n - The input number
         * @param {Array<number>} standardSequence - The complete standard Collatz sequence
         * @param {Object} optimizedResult - The result from calculateOptimizedStoppingTime
         * @returns {void} No return value; delegates to display functions
         * 
         * @example
         * const n = 27;
         * const standardSeq = [27, 82, 41, ..., 1];
         * const optimized = {
         *   total_stopping_time: 111,
         *   algorithm: "wormhole",
         *   prediction_type: "entry_point_found",
         *   computed_steps: 16,
         *   saved_steps: 95
         * };
         * 
         * displayResults(n, standardSeq, optimized);
         * // → Updates info cards with metrics
         * // → Shows sequence comparison
         * // → Explains wormhole strategy used
         */
        function displayResults(n, standardSequence, optimizedResult) {
            displayInfoCards(optimizedResult, n);
            displaySequences(n, standardSequence, optimizedResult);
            displayStrategy(optimizedResult, n);
        }

        /**
         * Displays the information cards showing key metrics and statistics.
         * 
         * Creates a grid of cards presenting the analysis results in an organized,
         * visually distinct format. Each card highlights a specific metric with
         * appropriate color coding to indicate the algorithm type and efficiency.
         * 
         * ALGORITHM CLASSIFICATION:
         * The function handles three main algorithms:
         * 
         * 1. MULTIPLICITIES (η=1, 100% efficiency)
         *    - Instant calculation using pre-computed patterns
         *    - Two subcases:
         *      a) General: n = e(m_r) × 2^k, e(m_r) > 1
         *         - computed steps: 0, saved steps: σ(n)
         *      b) Powers of 2: n = 2^k (e(m_r)=1, τ=0)
         *         - computed steps: 0, saved steps: σ(n)
         *         - Formula: σ(2^k) = k
         * 
         * 2. WORMHOLE (η=τ(m_r)/σ(n), variable efficiency)
         *    - Entry point found: hybrid calculation
         *    - computed steps: k (steps iterated to reach e(m_r))
         *    - saved steps: τ(m_r)
         *    - η = τ(m_r)/σ(n) = 1 - k/σ(n)
         * 
         * 3. STANDARD (η=0, 0% efficiency)
         *    - No optimization available
         *    - computed steps: σ(n), saved steps: 0
         * 
         * EFFICIENCY DEFINITION (aligned with paper):
         * η = 1 - k/σ(n) where k are the iterated steps:
         *    Multiplicities: k=0 (k obtained analytically) → η=1
         *    Wormholes:      k=steps to e(m_r)             → η=τ(m_r)/σ(n)
         *    Standard:       k=σ(n)                         → η=0
         * 
         * @param {Object} result - The optimized result object
         * @param {number} result.total_stopping_time - Total steps to reach 1
         * @param {string} result.algorithm - "multiplicity" or "wormhole"
         * @param {string} result.prediction_type - "multiplicity_found", "entry_point_found", or "no_entry_point"
         * @param {number} [result.index_used] - Which dictionary index was used (1 indicates powers of 2, S(0) case)
         * @param {number} [result.computed_steps] - Steps actually iterated
         * @param {number} [result.saved_steps] - Steps saved via dictionary
         * @param {number} [result.mr_value] - The mr class value
         * @param {number} n - The input number
         * @returns {void} Updates the DOM element with id 'infoGrid'
         * 
         * @example
         * // POWER OF 2 CASE (e(m_r)=1, special multiplicity)
         * displayInfoCards({
         *   total_stopping_time: 9,
         *   algorithm: "multiplicity",
         *   prediction_type: "multiplicity_found",
         *   index_used: 1,
         *   tau_mr: 0,
         *   analytical_steps: 9,
         *   mr_value: 0
         * }, 512);
         * // → Shows: Algorithm=Multiplicity S(0), Total=9, Computed=0, Saved=9, mr=0, η=1
         * 
         * // GENERAL MULTIPLICITY CASE
         * displayInfoCards({
         *   total_stopping_time: 11,
         *   algorithm: "multiplicity",
         *   prediction_type: "multiplicity_found",
         *   index_used: 6,
         *   tau_mr: 8,
         *   analytical_steps: 3,
         *   mr_value: 2
         * }, 48);
         * // → Shows: Algorithm=Multiplicity, Total=11, Computed=0, Saved=11, mr=2, η=1
         * 
         * // WORMHOLE CASE
         * displayInfoCards({
         *   total_stopping_time: 111,
         *   algorithm: "wormhole",
         *   prediction_type: "entry_point_found",
         *   computed_steps: 16,
         *   saved_steps: 95,
         *   mr_value: 60
         * }, 27);
         * // → Shows: Algorithm=Wormhole, Total=111, Computed=16, Saved=95, mr=60, η=0.8559
         * 
         * // STANDARD CASE
         * displayInfoCards({
         *   total_stopping_time: 17,
         *   algorithm: "wormhole",
         *   prediction_type: "no_entry_point",
         *   computed_steps: 17,
         *   saved_steps: 0
         * }, 93);
         * // → Shows: Algorithm=Standard, Total=17, Computed=17, Saved=0, mr=0, η=0
         */
        function displayInfoCards(result, n) {
            const infoGrid = document.getElementById('infoGrid');
            
            // Determine algorithm name for display
            let algorithm;
            
            if (result.algorithm === 'multiplicity') {
                // Powers of 2 are special multiplicities with e(m_r)=1
                algorithm = result.index_used === 1 
                    ? 'Multiplicity S(0)' 
                    : 'Multiplicity';
            } else if (result.algorithm === 'wormhole') {
                algorithm = result.prediction_type === 'entry_point_found' 
                    ? 'Wormhole' 
                    : 'Standard';
            } else {
                algorithm = 'Standard';
            }

            // Determine mr value for display
            const mrValue = result.mr_value !== undefined ? result.mr_value : 
                (result.prediction_type === 'no_entry_point' || result.prediction_type === 'trivial' ? 0 : 'N/A');
            
            // Calculate computed/saved steps and efficiency η = 1 - k/σ(n)
            let computedSteps, savedSteps, efficiency;
            
            if (result.algorithm === 'multiplicity') {
                // Multiplicities: k=0 (obtained analytically), η=1
                computedSteps = 0;
                savedSteps = result.total_stopping_time;
                efficiency = '100.0';
            } else {
                // Wormhole or Standard
                computedSteps = result.computed_steps || 0;
                savedSteps = result.saved_steps || 0;
                efficiency = result.total_stopping_time > 0
                    ? ((1 - computedSteps / result.total_stopping_time) * 100).toFixed(1)
                    : '0.0';
            }

            // Generate HTML for all info cards
            infoGrid.innerHTML = `
                <div class="info-card">
                    <div class="info-label">Algorithm Used</div>
                    <div class="info-value">${algorithm}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Total Stopping Time σ(n)</div>
                    <div class="info-value">${result.total_stopping_time}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Computed Steps k</div>
                    <div class="info-value computed-value">${computedSteps}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Saved Steps τ(m<sub>r</sub>)</div>
                    <div class="info-value saved-value">${savedSteps}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Class S(m<sub>r</sub>)</div>
                    <div class="info-value">${mrValue}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Efficiency η</div>
                    <div class="info-value">${efficiency}%</div>
                </div>
            `;
        }

        /**
         * Displays side-by-side comparison of standard vs optimized sequences.
         * 
         * Shows the actual number sequences with visual color coding to distinguish
         * between different optimization types and computed vs saved steps.
         * The display adapts based on which optimization algorithm was used.
         * 
         * DISPLAY MODES:
         * 
         * 0. POWER OF 2 MODE:
         *    - Standard sequence: shown in full
         *    - Optimized: shows "Pure power of 2" message with blue color
         *    - Explains the trivial trajectory (successive divisions by 2)
         *    - No intermediate computation needed
         * 
         * 1. MULTIPLICITY MODE:
         *    - Standard sequence: shown in full
         *    - Optimized: shows "Direct calculation" message (no sequence needed)
         *    - No color coding (instant calculation, no iteration)
         * 
         * 2. WORMHOLE MODE (entry point found):
         *    - Standard sequence: shown in full
         *    - Optimized sequence: split into two color-coded parts:
         *      a) Computed part (yellow #fdcb6e): manually calculated steps
         *      b) Wormhole part (green #2ecc71): saved steps from dictionary
         *    - Legend: shows color coding explanation
         * 
         * 3. STANDARD MODE (no optimization):
         *    - Standard sequence: shown in full
         *    - Message: indicates full computation was required
         *    - No color coding (no optimization available)
         * 
         * VISUAL ELEMENTS:
         * - Arrow symbols (→) between numbers for readability
         * - Color coding: blue for powers of 2, yellow for computed, green for saved
         * - Element and step counts in labels
         * - Interactive legend for wormhole mode
         * 
         * @param {number} n - The input number
         * @param {Array<number>} standardSeq - Complete standard Collatz sequence
         * @param {Object} optimizedResult - The optimized result object
         * @param {string} optimizedResult.algorithm - "power_of_2", "multiplicity" or "wormhole"
         * @param {string} optimizedResult.prediction_type - Type of prediction
         * @param {number} [optimizedResult.exponent] - Exponent for power of 2
         * @param {number} [optimizedResult.entry_point_position] - Position where wormhole was found
         * @param {number} [optimizedResult.entry_point_found] - Value that triggered wormhole
         * @returns {void} Updates the DOM element with id 'sequenceDisplay'
         * 
         * @example
         * displaySequences(16, [16, 8, 4, 2, 1], {
         *   algorithm: "power_of_2",
         *   prediction_type: "power_of_2",
         *   exponent: 4,
         *   total_stopping_time: 4
         * });
         * // → Shows standard sequence in white
         * // → Shows "Pure power of 2: 16 = 2^4" message in blue
         * 
         * displaySequences(27, [27, 82, ..., 1], {
         *   algorithm: "wormhole",
         *   prediction_type: "entry_point_found",
         *   entry_point_position: 16,
         *   entry_point_found: 121
         * });
         * // → Shows standard sequence in white
         * // → Shows optimized with 16 yellow steps, then green wormhole
         * // → Displays legend explaining colors
         */
        function displaySequences(n, standardSeq, optimizedResult) {
            const display = document.getElementById('sequenceDisplay');
            
            // ALWAYS show standard sequence first
            let html = `
                <div class="sequence-row">
                    <div class="sequence-label">Standard Sequence (${standardSeq.length} elements, ${standardSeq.length - 1} steps):</div>
                    <div class="sequence-values">
                        ${standardSeq.map((num, i) => 
                            `<span class="sequence-num">${num}</span>${i < standardSeq.length - 1 ? '<span class="arrow">→</span>' : ''}`
                        ).join('')}
                    </div>
                </div>
            `;
            
            // CASE 0: POWER OF 2 algorithm was used
            if (optimizedResult.algorithm === 'power_of_2') {
                html += `
                    <div class="sequence-row">
                        <div class="sequence-label">Optimized Sequence:</div>
                        <div class="sequence-values">
                            <span style="color: #3498db;">Pure power of 2: ${n} = 2<sup>${optimizedResult.exponent}</sup> reaches 1 via ${optimizedResult.total_stopping_time} successive divisions by 2 (${optimizedResult.total_stopping_time + 1} elements, ${optimizedResult.total_stopping_time} steps)</span>
                        </div>
                    </div>
                `;
            // CASE 1: MULTIPLICITY algorithm was used
            } else if (optimizedResult.algorithm === 'multiplicity') {
                html += `
                    <div class="sequence-row">
                        <div class="sequence-label">Optimized Sequence:</div>
                        <div class="sequence-values">
                            <span style="color: #2ecc71;">Direct calculation using multiplicities (${optimizedResult.total_stopping_time + 1} elements, ${optimizedResult.total_stopping_time} steps)</span>
                        </div>
                    </div>
                `;
            // CASE 2: WORMHOLE entry point was found
            } else if (optimizedResult.prediction_type === 'entry_point_found') {
                const entryPos = optimizedResult.entry_point_position;
                const entryPoint = optimizedResult.entry_point_found;

                // Build the COMPUTED part (before wormhole)
                const computedPart = [];
                let current = n;
                for (let i = 0; i <= entryPos; i++) {
                    computedPart.push(current);
                    if (current !== 1) {
                        current = nextCollatzValue(current);
                    }
                }
                
                // Get the WORMHOLE part (pre-calculated sequence)
                // slice(1) because first element is already in computedPart
                const wormholePart = WORMHOLES_DICTIONARY[entryPoint].wormhole.slice(1);
                
                html += `
                    <div class="sequence-row">
                        <div class="sequence-label">Optimized Sequence (${computedPart.length + wormholePart.length} elements, ${computedPart.length + wormholePart.length - 1} steps):</div>
                        <div class="sequence-values">
                            ${computedPart.map((num, i) => 
                                `<span class="sequence-num" style="color: #fdcb6e;">${num}</span>${i < computedPart.length - 1 ? '<span class="arrow">→</span>' : ''}`
                            ).join('')}
                            ${wormholePart.length > 0 ? '<span class="arrow">→</span>' : ''}
                            ${wormholePart.map((num, i) => 
                                `<span class="sequence-num" style="color: #2ecc71;">${num}</span>${i < wormholePart.length - 1 ? '<span class="arrow">→</span>' : ''}`
                            ).join('')}
                        </div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #fdcb6e;"></div>
                                <span>Computed steps</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2ecc71;"></div>
                                <span>Wormhole steps</span>
                            </div>
                        </div>
                    </div>
                `;
            // CASE 3: NO optimization available
            } else {
                html += `
                    <div class="sequence-row">
                        <div class="sequence-label">Optimized Sequence:</div>
                        <div class="sequence-values">
                            <span style="color: #e74c3c;">No optimizations available, so full computation required</span>
                        </div>
                    </div>
                `;
            }
            
            // Update the display
            display.innerHTML = html;
        }

        /**
         * Displays the optimization strategy explanation in human-readable format.
         * 
         * Provides a clear, detailed description of HOW the result was calculated,
         * helping users understand the mathematical reasoning behind the optimization.
         * The explanation adapts based on which algorithm was used.
         * 
         * ALGORITHM TYPES (aligned with paper):
         * 
         * 1. MULTIPLICITIES (η=1): Two subcases
         *    a) General: n = e(m_r) × 2^k, e(m_r) > 1
         *       - Shows entry point e(m_r), τ(m_r), k obtained analytically
         *       - Formula: σ(n) = k + τ(m_r)
         *    b) Powers of 2: n = 2^k (e(m_r)=1, τ=0)
         *       - Special multiplicity with e(m_r)=1
         *       - Formula: σ(2^k) = k (obtained analytically, no iteration)
         * 
         * 2. WORMHOLE (η=τ(m_r)/σ(n)):
         *    - Shows entry point e(m_r) reached after k iterated steps
         *    - Formula: σ(n) = k + τ(m_r)
         *    - η = τ(m_r)/σ(n) = 1 - k/σ(n)
         * 
         * 3. STANDARD (η=0):
         *    - Full iteration required, no optimization available
         * 
         * @param {Object} result - The optimized result object
         * @param {number} n - The input number
         * @param {string} result.algorithm - "multiplicity" or "wormhole"
         * @param {string} result.prediction_type - Type of prediction used
         * @param {number} [result.index_used] - Entry point e(m_r) (1 for powers of 2, S(0) case)
         * @param {number} [result.ratio] - n/e(m_r) ratio (always a power of 2)
         * @param {number} [result.tau] - Precomputed τ(m_r)
         * @param {number} [result.analytical_steps] - k = log₂(n/e(m_r))
         * @param {number} [result.entry_point_found] - Entry point value (wormhole)
         * @param {number} [result.entry_point_position] - k iterated steps to e(m_r)
         * @param {number} [result.wormhole_length] - Length of wormhole sequence
         * @param {number} [result.computed_steps] - k iterated steps
         * @param {number} [result.saved_steps] - τ(m_r) saved steps
         * @param {number} [result.mr_value] - The mr class value
         * @returns {void} Updates the DOM element with id 'strategyContent'
         * 
         * @example
         * // POWER OF 2 CASE (special multiplicity, e(m_r)=1)
         * displayStrategy({
         *   algorithm: "multiplicity",
         *   prediction_type: "multiplicity_found",
         *   index_used: 1,
         *   tau_mr: 0,
         *   analytical_steps: 9,
         *   total_stopping_time: 9,
         *   mr_value: 0
         * }, 512);
         * // → "Special multiplicity: 512 = 1 × 2^9, e(m_r)=1, τ=0
         * //    k=9 obtained analytically, σ(512) = 0 + 9 = 9, η=1"
         * 
         * // GENERAL MULTIPLICITY CASE
         * displayStrategy({
         *   algorithm: "multiplicity",
         *   prediction_type: "multiplicity_found",
         *   index_used: 6,
         *   ratio: 8,
         *   tau_mr: 8,
         *   analytical_steps: 3,
         *   total_stopping_time: 11,
         *   mr_value: 2
         * }, 48);
         * // → "e(m_r)=6 from mr=2, τ=8, k=log₂(8)=3 obtained analytically
         * //    σ(48) = 3 + 8 = 11, η=1"
         * 
         * // WORMHOLE CASE
         * displayStrategy({
         *   algorithm: "wormhole",
         *   prediction_type: "entry_point_found",
         *   entry_point_found: 121,
         *   entry_point_position: 16,
         *   computed_steps: 16,
         *   saved_steps: 95,
         *   total_stopping_time: 111,
         *   mr_value: 60
         * }, 27);
         * // → "e(m_r)=121 from mr=60 reached after k=16 iterated steps
         * //    τ(m_r)=95, σ(27) = 16 + 95 = 111, η=95/111≈0.856"
         * 
         * // STANDARD CASE
         * displayStrategy({
         *   algorithm: "wormhole",
         *   prediction_type: "no_entry_point",
         *   total_stopping_time: 17,
         *   computed_steps: 17,
         *   saved_steps: 0
         * }, 93);
         * // → "Full iteration required, σ(93)=17, η=0"
         */
        function displayStrategy(result, n) {
            const strategyContent = document.getElementById('strategyContent');
            
            if (result.algorithm === 'multiplicity') {
                
                if (result.index_used === 1) { // Multiplicity S(0)
                    // CASE 1a: Powers of 2 (special multiplicity with e(m_r)=1, τ=0)
                    strategyContent.innerHTML = `
                        <div class="strategy-item">
                            <strong>Multiplicities algorithm (special case of S(0)):</strong> the Collatz function (only the even branch) is applied iteratively 
                            until reaching the entry point e(m<sub>r</sub>) = <strong>1</strong>, 
                            taking k = log<sub>2</sub>(${n}/1) = log<sub>2</sub>(${n}) = ${result.analytical_steps} analytically steps (no iterations required).
                            From there, the τ(m<sub>r</sub>) = <strong>0</strong> indicates no steps needed. </br>
                            Finally, σ(${n}) = k + τ(m<sub>r</sub>) = ${result.analytical_steps} + 0 = <strong>${result.total_stopping_time}</strong>, with η=1
                        </div>
                    `;
                } else {
                    // CASE 1b: General multiplicity (e(m_r) > 1)
                    strategyContent.innerHTML = `
                        <div class="strategy-item">
                            <strong>Multiplicities algorithm:</strong> the Collatz function (only the even branch) is applied 
                            iteratively until reaching the entry point e(m<sub>r</sub>) = <strong>${result.index_used}</strong>, 
                            taking k = log<sub>2</sub>(${result.n}/${result.index_used}) = log<sub>2</sub>(${result.ratio}) = 
                            <strong>${result.analytical_steps}</strong> analytical steps (no iterations required). 
                            From there, the τ(m<sub>r</sub>) = <strong>${result.tau_mr}</strong> remaining steps are obtained 
                            from the dictionary. </br>
                            Finally, σ(${n}) = k + τ(m<sub>r</sub>) = ${result.analytical_steps} + ${result.tau_mr} = <strong>${result.total_stopping_time}</strong>, with η=1
                        </div>
                    `;
                }

            } else if (result.prediction_type === 'entry_point_found') {
                // CASE 2: Wormhole
                strategyContent.innerHTML = `
                    <div class="strategy-item">
                        <strong>Wormholes algorithm</strong>: the Collatz function is applied iteratively 
                        until reaching entry point e(m<sub>r</sub>) = <strong>${result.entry_point_found}</strong>, 
                        taking k = <strong>${result.computed_steps}</strong> computed steps. 
                        From there, the τ(m<sub>r</sub>) = <strong>${result.tau_mr}</strong> remaining 
                        steps are obtained from the dictionary. </br>
                        Finally, σ(${n}) = k + τ(m<sub>r</sub>) = ${result.computed_steps} + ${result.tau_mr} = 
                        <strong>${result.total_stopping_time}</strong>, with 
                        η = ${result.tau_mr}/${result.total_stopping_time} ≈ 
                        ${(result.tau_mr/result.total_stopping_time).toFixed(4)}
                    </div>
                `;

            } else {
                // CASE 3: Standard
                strategyContent.innerHTML = `
                    <div class="strategy-item">
                        <strong>Standard Algorithm:</strong> the Collatz function is applied iteratively until reaching the trivial cycle, 
                        and no multiplicity or wormhole pattern detected.</br>
                        Finally, σ(${n}) = <strong>${result.total_stopping_time}</strong>, with η=0
                    </div>
                `;
            }
        }

        /**
         * DOM Content Loaded event listener - initializes the application.
         * 
         * Sets up the initial state of the application when the page loads.
         * This ensures a clean starting state and configures user interaction handlers.
         * 
         * INITIALIZATION TASKS:
         * 1. Clears the input field to prevent cached values
         * 2. Sets up Enter key handler for convenient form submission
         * 
         * ENTER KEY BEHAVIOR:
         * Allows users to press Enter in the input field instead of clicking
         * the "Process" button, improving user experience and accessibility.
         * 
         * @listens DOMContentLoaded
         * @returns {void} No return value; sets up event handlers
         * 
         * @example
         * // When page loads:
         * document.addEventListener('DOMContentLoaded', function() {
         *   // Input field is cleared
         *   // Enter key triggers processNumber()
         * });
         */
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('numberInput').value = '';
            
            document.getElementById('numberInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    processNumber();
                }
            });
        });
    </script>
</body>
</html>